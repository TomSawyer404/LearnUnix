# 用户与文件操作
## who是如何工作的?
输出指令 `unix> man who`, 阅读manual手册, 在ubuntu LTS 20.04我们可以找到如下信息:
> If FILE is not specified, use /var/run/utmp. /var/lo/wtmp as FILE is common. If ARG1 ARG2 given, `-m` presumed: 'am i' or 'mom likes' are usual.

根据上述信息, 我们继续知道已登录用户的信息是放在文件 /var/run/utmp 或 /var/lo/wtmp
我们输入命令 `unix> man -k utmp`, 来根据关键字搜索联机帮助:
```screen
...
utmp (5)     - login records
utmpdump (1) - dump UTMP and WTMP files in raw format
utmpname (3) - access utmp file entries
...
```
看起来第5小节有我们所需要的信息, 在命令行输入`unix> man 5 utmp`.
阅读手册后, 我们可以得知: utmp文件里头有结构数组, 数组元素是utmp类型的结构体.

由此我们可以猜测**who**的工作逻辑:
```pseudocode
打开utmp;
while 读取记录 != false:
    显示记录;
```
我们可以动手了.

## 如何编写who
写程序之前, 我们有两个问题:
1. 如何从文件中读取结构体
2. 如何将结构体的信息以合适的方式展现出来

### 如何从文件中读取数据结构
我们当然可以用第一章中C标准库的函数`fgets()`或`getc()`, 但这些函数要么是一次性读一行, 要么是一次一个byte的读, 如果有那种一次性读一个结构的函数就好了.
我们继续查阅manual的联机帮助, 我们找与file和read有关的信息:
```bash
unix> man -k file | grep read
```
其中最有可能的是`read (2)  - read from a file descriptor`.
我们在命令行输入`unix> man 2 read`来查看帮助文档.
从`Description`中我们得知, `read()`函数能读取我们自定义长度的数据, 由于我们要读取的是结构体, 在实践中我们用`sizeof(struct utmp)`就能指定我们需要的长度了.

读取文件之前肯定要打开文件, 读取完后要关闭文件. 在手册的`SEE ALSO`项中我们知道其他两个系统调用函数是`open()`和`close()`. 我们所需要的方法已经齐全了. 
总结manual手册信息, 我们需要的头文件:
- 打开utmp文件: `<utmp.h>`
- read(), close()系统调用: `<unistd.h>`
- open()系统调用: `<sys/types.h>`, `sys/stat.h`, `<fcntl.h>`

### open()系统调用
打开文件是内核提供的服务, 如果在打开过程中内核检测到任何错误, 这个系统调用就会返回-1.
如果这个文件被顺利打开, 内核会返回一个正整数值, 这数值就叫做**文件描述符**. 打开文件会建立进程和文件之间的连接, **文件描述符** 就是用来唯一标识这个链接的. 
如果同时打开好几个文件, 它们所对应的文件描述符是不同的, 如果将一个文件打开多次, 对应的文件描述符也不同.

## 编写who01.c
**who**的基本功能已经实现, 但和内置的**who**相比, 还存在两个问题:
1. 有多余的空白记录
2. 时间显示不正确

## 编写who02.c
### 清除多余的空白记录
utmp包含所以终端的信息, 为了达到仅显示已登录用户信息的目的, 我们可以过滤掉用户名为空的记录.

阅读manual手册, 我们观察到utmp结构体有一项`ut_type`的short值, 从手册可知, 当`ut_type`值为7时, 表示这是一个`Normal process`.
根据这一点, 我们对程序进行修改, 以消除多余的空白记录.


### 正确显示时间
在命令行输入`unix> man -k time | grep transform`. 我们阅读关于`ctime()`的信息.
#### Unix存储时间的方式
Unix中的时间采用一个整数来表示, 它的数值是从1970j年1月1日0时开始所经过的秒数, 在头文件`time.h`中有: `typedef long int time_t`

#### 将时间显示出来
`ctime()`将表示时间的整数值转化为人们可以阅读的时间形式. 我们根据manual手册有关`ctime()`的信息修改`who01.c`的内容.

## 编写who03.c
### 内核模式与用户模式
系统调用(system call)是操作系统提供给用户访问硬件资源的方法. 我们的内存空间被分成2个部分, 一个是操作系统自己的空间(内核空间), 一个是用户自己的内存空间. 
用户的进程位于用户空间, 而硬件资源只能被内核之间访问. 当我们需要调用硬件资源时, 必须借助操作系统的system call.
程序员使用system call, 会**陷入**到内核空间, 这实质上是发生了进程的上下文切换, 这一过程是要花费时间的.([参考CSAPP异常控制流](http://csapp.cs.cmu.edu/2e/ch8-preview.pdf))
举个蜘蛛侠的例子. 当Peter(普通人)要从用户模式切换到管理员模式(蜘蛛侠), 他得先找个地方, 比如小巷, 脱下校服, 摘掉眼镜, 再套上初代的蜘蛛衣, 变身成蜘蛛侠后才能去拯救别人. 完事后, 还得找个地方变回普通人. 变来变去是需要事件的, 要是Peter整体忙于变来变去, 就不会有太多时间来拯救百姓了.

### 问题
在`who02.c`中, 每次`read()`系统调用只读取了一个结构体, 这造成会反复陷入内核, 程序的效率十分低下.
使用**缓冲区**技术能帮助我们改善这一问题.

> 假设我们要炒3个鸡蛋, 但家里只有1个. 
> - 不用缓冲区: 炒一个鸡蛋, 再去超市买一个鸡蛋, 炒完后再去超市买一个鸡蛋, 最后炒完.
> - 使用缓冲区: 炒一个鸡蛋, 去超市买一大箩筐鸡蛋回家; 从箩筐拿2个鸡蛋炒.

我们把实现写在`utmplib.c`里.

---
